<div class="content-section">
    <div class="mb-8">
        <div class="flex items-center mb-4">
            <div class="w-3 h-8 bg-red-500 rounded-full mr-4"></div>
            <h2 class="text-3xl font-bold text-gray-900">Part 5: Advanced Concepts</h2>
        </div>
        <p class="text-lg text-gray-600 mb-6 leading-relaxed">To write cleaner and more powerful queries, KQL provides features like variables and in-memory tables. In this section, you'll learn how to use <code class="bg-blue-50 text-blue-700 px-2 py-1 rounded-md font-mono text-sm">let</code> statements to define reusable expressions and <code class="bg-blue-50 text-blue-700 px-2 py-1 rounded-md font-mono text-sm">datatable</code> to create temporary tables for filtering or testing.</p>
    </div>
    
     <div>
        <h3 class="text-xl font-semibold mb-6 mt-8 text-gray-800">1. Reusable Expressions with <code class="text-lg">let</code></h3>
        <p class="mb-6">A <code class="bg-blue-50 text-blue-700 px-2 py-1 rounded-md font-mono text-sm">let</code> statement assigns a name to an expression or function. This is extremely useful for breaking complex queries into logical, readable parts.</p>
         <div class="code-block relative rounded-lg p-4 font-mono text-sm my-6">
            <div class="flex space-x-2 absolute top-2 right-2">
                <button class="copy-btn bg-blue-100 text-blue-800 px-2 py-1 rounded-md text-xs hover:bg-blue-200 transition-colors">Copy</button>
            </div>
            <pre><code><span class="kql-comment">// Find the role of the user with the most failed logins</span>
<span class="kql-keyword">let</span> FailedLogins <span class="kql-pipe">=</span> <span class="kql-table">AuthenticationEvents</span>
<span class="kql-pipe">|</span> <span class="kql-keyword">where</span> result <span class="kql-pipe">==</span> <span class="kql-string">"Failed Login"</span>
<span class="kql-pipe">|</span> <span class="kql-keyword">summarize</span> <span class="kql-function">count()</span> <span class="kql-keyword">by</span> username
<span class="kql-pipe">|</span> <span class="kql-keyword">top</span> 1 <span class="kql-keyword">by</span> count_;
<span class="kql-comment">// Now join that result to the Employees table</span>
FailedLogins
<span class="kql-pipe">|</span> <span class="kql-keyword">join</span> kind<span class="kql-pipe">=</span>inner <span class="kql-table">Employees</span> <span class="kql-keyword">on</span> username
<span class="kql-pipe">|</span> <span class="kql-keyword">project</span> name, role, FailedLoginCount <span class="kql-pipe">=</span> count_</code></pre>
        </div>
    </div>
    
     <div>
        <h3 class="text-xl font-semibold mb-6 mt-8 text-gray-800">2. In-Memory Tables with <code class="text-lg">datatable</code></h3>
        <p class="mb-6">The <code class="bg-blue-50 text-blue-700 px-2 py-1 rounded-md font-mono text-sm">datatable</code> operator lets you define a small, temporary table directly in your query. It's perfect for filtering against a known list of values, for example, a list of specific IP addresses you want to investigate.</p>
         <div class="code-block relative rounded-lg p-4 font-mono text-sm my-6">
            <div class="flex space-x-2 absolute top-2 right-2">
                <button class="copy-btn bg-blue-100 text-blue-800 px-2 py-1 rounded-md text-xs hover:bg-blue-200 transition-colors">Copy</button>
            </div>
            <pre><code><span class="kql-keyword">let</span> T <span class="kql-pipe">=</span> <span class="kql-function">datatable</span>(src_ip: <span class="kql-keyword">string</span>) [
    <span class="kql-string">'58.128.200.24'</span>,
    <span class="kql-string">'106.110.117.45'</span>,
    <span class="kql-string">'113.224.96.5'</span>
];
<span class="kql-table">AuthenticationEvents</span>
<span class="kql-pipe">|</span> <span class="kql-keyword">where</span> src_ip <span class="kql-keyword">in</span> (T)</code></pre>
        </div>
    </div>
    
    <div>
        <h3 class="text-xl font-semibold mb-6 mt-8 text-gray-800">3. Optimize with <code class="text-lg">materialize</code></h3>
        <p class="mb-6">The <code class="bg-blue-50 text-blue-700 px-2 py-1 rounded-md font-mono text-sm">materialize</code> operator caches the result of a subquery expression so it can be referenced multiple times without recomputing. This is especially useful when you need to use the same complex calculation or dataset multiple times in your query, improving performance and reducing resource usage.</p>
        
        <div class="code-block relative rounded-lg p-4 font-mono text-sm my-6">
            <div class="flex space-x-2 absolute top-2 right-2">
                <button class="copy-btn bg-blue-100 text-blue-800 px-2 py-1 rounded-md text-xs hover:bg-blue-200 transition-colors">Copy</button>
            </div>
            <pre><code><span class="kql-comment">// Calculate failed logins once and reuse the result</span>
<span class="kql-keyword">let</span> FailedLoginData <span class="kql-pipe">=</span> <span class="kql-function">materialize</span>(
    <span class="kql-table">AuthenticationEvents</span>
    <span class="kql-pipe">|</span> <span class="kql-keyword">where</span> result <span class="kql-pipe">==</span> <span class="kql-string">"Failed Login"</span>
    <span class="kql-pipe">|</span> <span class="kql-keyword">where</span> timestamp <span class="kql-pipe">&gt;=</span> <span class="kql-function">ago</span>(7d)
);
<span class="kql-comment">// Now use the materialized data multiple times without recomputation</span>
<span class="kql-keyword">union</span>
    (FailedLoginData <span class="kql-pipe">|</span> <span class="kql-keyword">summarize</span> TotalFailedLogins <span class="kql-pipe">=</span> <span class="kql-function">count()</span>),
    (FailedLoginData <span class="kql-pipe">|</span> <span class="kql-keyword">summarize</span> UniqueUsers <span class="kql-pipe">=</span> <span class="kql-function">dcount</span>(username)),
    (FailedLoginData <span class="kql-pipe">|</span> <span class="kql-keyword">summarize</span> UniqueIPs <span class="kql-pipe">=</span> <span class="kql-function">dcount</span>(src_ip))</code></pre>
        </div>
        
        <div class="bg-green-50 border-l-4 border-green-400 p-4 rounded-r-lg mt-4">
            <div class="flex">
                <div class="flex-shrink-0">
                    <svg class="h-5 w-5 text-green-400" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"/>
                    </svg>
                </div>
                <div class="ml-3">
                    <p class="text-sm text-green-700">
                        <strong>Performance Tip:</strong> Without <code class="bg-green-100 text-green-800 px-1 py-0.5 rounded font-mono text-xs">materialize</code>, the filtered authentication events would be computed three separate times. 
                        With <code class="bg-green-100 text-green-800 px-1 py-0.5 rounded font-mono text-xs">materialize</code>, the expensive filtering operation runs only once, and the cached result is reused for all three summarizations.
                    </p>
                </div>
            </div>
        </div>
    </div>
</div>