<div class="content-section">
    <div class="mb-8">
        <div class="flex items-center mb-4">
            <div class="w-3 h-8 bg-red-500 rounded-full mr-4"></div>
            <h2 class="text-3xl font-bold text-gray-900">Part 5: Advanced Concepts</h2>
        </div>
        <p class="text-lg text-gray-600 mb-6 leading-relaxed">To write cleaner and more powerful queries, KQL provides features like variables and in-memory tables. In this section, you'll learn how to use <code class="bg-blue-50 text-blue-700 px-2 py-1 rounded-md font-mono text-sm">let</code> statements to define reusable expressions and <code class="bg-blue-50 text-blue-700 px-2 py-1 rounded-md font-mono text-sm">datatable</code> to create temporary tables for filtering or testing.</p>
    </div>
    
     <div>
        <h3 class="text-xl font-semibold mb-6 mt-8 text-gray-800">1. Reusable Expressions with <code class="text-lg">let</code></h3>
        <p class="mb-6">A <code class="bg-blue-50 text-blue-700 px-2 py-1 rounded-md font-mono text-sm">let</code> statement assigns a name to an expression or function. This is extremely useful for breaking complex queries into logical, readable parts.</p>
         <div class="code-block relative rounded-lg p-4 font-mono text-sm my-6">
            <div class="flex space-x-2 absolute top-2 right-2">
                <button class="copy-btn bg-blue-100 text-blue-800 px-2 py-1 rounded-md text-xs hover:bg-blue-200 transition-colors">Copy</button>
            </div>
            <pre><code><span class="kql-comment">// Find the role of the user with the most failed logins</span>
<span class="kql-keyword">let</span> FailedLogins <span class="kql-pipe">=</span> <span class="kql-table">AuthenticationEvents</span>
<span class="kql-pipe">|</span> <span class="kql-keyword">where</span> result <span class="kql-pipe">==</span> <span class="kql-string">"Failed Login"</span>
<span class="kql-pipe">|</span> <span class="kql-keyword">summarize</span> <span class="kql-function">count()</span> <span class="kql-keyword">by</span> username
<span class="kql-pipe">|</span> <span class="kql-keyword">top</span> 1 <span class="kql-keyword">by</span> count_;
<span class="kql-comment">// Now join that result to the Employees table</span>
FailedLogins
<span class="kql-pipe">|</span> <span class="kql-keyword">join</span> kind<span class="kql-pipe">=</span>inner <span class="kql-table">Employees</span> <span class="kql-keyword">on</span> username
<span class="kql-pipe">|</span> <span class="kql-keyword">project</span> name, role, FailedLoginCount <span class="kql-pipe">=</span> count_</code></pre>
        </div>
    </div>
    
     <div>
        <h3 class="text-xl font-semibold mb-6 mt-8 text-gray-800">2. In-Memory Tables with <code class="text-lg">datatable</code></h3>
        <p class="mb-6">The <code class="bg-blue-50 text-blue-700 px-2 py-1 rounded-md font-mono text-sm">datatable</code> operator lets you define a small, temporary table directly in your query. It's perfect for filtering against a known list of values, for example, a list of specific IP addresses you want to investigate.</p>
         <div class="code-block relative rounded-lg p-4 font-mono text-sm my-6">
            <div class="flex space-x-2 absolute top-2 right-2">
                <button class="copy-btn bg-blue-100 text-blue-800 px-2 py-1 rounded-md text-xs hover:bg-blue-200 transition-colors">Copy</button>
            </div>
            <pre><code><span class="kql-keyword">let</span> T <span class="kql-pipe">=</span> <span class="kql-function">datatable</span>(src_ip: <span class="kql-keyword">string</span>) [
    <span class="kql-string">'58.128.200.24'</span>,
    <span class="kql-string">'106.110.117.45'</span>,
    <span class="kql-string">'113.224.96.5'</span>
];
<span class="kql-table">AuthenticationEvents</span>
<span class="kql-pipe">|</span> <span class="kql-keyword">where</span> src_ip <span class="kql-keyword">in</span> (T)</code></pre>
        </div>
    </div>
    
    <div>
        <h3 class="text-xl font-semibold mb-6 mt-8 text-gray-800">3. Optimize with <code class="text-lg">materialize</code></h3>
        <p class="mb-6">The <code class="bg-blue-50 text-blue-700 px-2 py-1 rounded-md font-mono text-sm">materialize</code> operator caches the result of a subquery expression so it can be referenced multiple times without recomputing. This is especially useful when you need to use the same complex calculation or dataset multiple times in your query, improving performance and reducing resource usage.</p>
        
        <div class="code-block relative rounded-lg p-4 font-mono text-sm my-6">
            <div class="flex space-x-2 absolute top-2 right-2">
                <button class="copy-btn bg-blue-100 text-blue-800 px-2 py-1 rounded-md text-xs hover:bg-blue-200 transition-colors">Copy</button>
            </div>
            <pre><code><span class="kql-keyword">let</span> FailedLoginData <span class="kql-pipe">=</span> <span class="kql-function">materialize</span> (
    <span class="kql-table">AuthenticationEvents</span>
    <span class="kql-pipe">|</span> <span class="kql-keyword">where</span> result <span class="kql-pipe">==</span> <span class="kql-string">"Failed Login"</span>
    <span class="kql-pipe">|</span> <span class="kql-keyword">extend</span> timestamp <span class="kql-pipe">=</span> <span class="kql-function">todatetime</span>(timestamp)
);
<span class="kql-comment">// Example 1: Count of failed logins per user</span>
FailedLoginData
<span class="kql-pipe">|</span> <span class="kql-keyword">summarize</span> FailedCount <span class="kql-pipe">=</span> <span class="kql-function">count()</span> <span class="kql-keyword">by</span> username;
<span class="kql-comment">// Example 2: Top 5 source IPs causing failed logins</span>
FailedLoginData
<span class="kql-pipe">|</span> <span class="kql-keyword">summarize</span> FailedAttempts <span class="kql-pipe">=</span> <span class="kql-function">count()</span> <span class="kql-keyword">by</span> src_ip
<span class="kql-pipe">|</span> <span class="kql-keyword">top</span> 5 <span class="kql-keyword">by</span> FailedAttempts <span class="kql-keyword">desc</span>;
<span class="kql-comment">// Example 3: Time series of failed logins</span>
FailedLoginData
<span class="kql-pipe">|</span> <span class="kql-keyword">summarize</span> Count <span class="kql-pipe">=</span> <span class="kql-function">count()</span> <span class="kql-keyword">by</span> <span class="kql-function">bin</span>(timestamp, 1h)
<span class="kql-pipe">|</span> <span class="kql-keyword">render</span> timechart</code></pre>
        </div>
        
        <div class="bg-green-50 border-l-4 border-green-400 p-4 rounded-r-lg mt-4">
            <div class="flex">
                <div class="flex-shrink-0">
                    <svg class="h-5 w-5 text-green-400" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"/>
                    </svg>
                </div>
                <div class="ml-3">
                    <p class="text-sm text-green-700">
                        <strong>Multiple Results:</strong> This query produces three separate tables and a visual timechart all at once, reusing the same filtered data. 
                        Without <code class="bg-green-100 text-green-800 px-1 py-0.5 rounded font-mono text-xs">materialize</code>, the failed login filtering would be computed three separate times, making it much less efficient.
                    </p>
                </div>
            </div>
        </div>
        
        <!-- Screenshot Example -->
        <div class="mt-6">
            <img src="../../images/samples/materialize_query_example.jpeg" alt="Materialize query example showing multiple tables and timechart visualization" class="w-full rounded-lg border border-gray-200 shadow-sm">
            <p class="text-sm text-gray-600 mt-2 text-center italic">
                Example showing multiple tables and timechart visualization results in Azure Data Explorer
            </p>
        </div>
        
        <div class="bg-blue-50 border-l-4 border-blue-400 p-4 rounded-r-lg mt-4">
            <div class="flex">
                <div class="flex-shrink-0">
                    <svg class="h-5 w-5 text-blue-400" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd"/>
                    </svg>
                </div>
                <div class="ml-3">
                    <p class="text-sm text-blue-700">
                        <strong>Note:</strong> The performance benefits of <code class="bg-blue-100 text-blue-800 px-1 py-0.5 rounded font-mono text-xs">materialize</code> are most valuable with large datasets containing millions or billions of records. 
                        You will not notice a significant performance difference when working with these smaller training datasets, but it's an essential optimization technique for production environments.
                    </p>
                </div>
            </div>
        </div>
    </div>
</div>